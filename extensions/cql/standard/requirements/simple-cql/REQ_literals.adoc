[[req_simple-cql_literals]] 
[width="90%",cols="2,6a"]
|===
^|*Requirement {counter:req-id}* |*/req/simple-cql/literals* 
^|A |A server that implements this conformance class shall support literals as defined by the following BNF fragment:

----
   #==========================================================================#
   # Definition of CHARACTER literals
   #==========================================================================#
   characterLiteral = characterStringLiteral
                   \| bitStringLiteral
                   \| hexStringLiteral;
   
   characterStringLiteral = quote \[ {character} \] quote;
   
   bitStringLiteral = "B" quote \[ {bit} \] quote;
   
   hexStringLiteral = "X" quote \[ {hexit} \] quote;
   
   character = alpha \| digit \| specialCharacter \| quoteQuote;
   
   quoteQuote = quote quote;
   
   # NOTE: This production is supposed to be any alphabetic character from
   #       the character set.
   #
   #       I use the A-Z, a-z range here as placeholders because:
   #       (a) I have no idea how to indicate that alpha can be
   #           any alphabetic UTF-8 character
   #       (b) the validators I am using can only handle ASCII chars
   #
   alpha = "A" \| "B" \| "C" \| "D" \| "E" \| "F" \| "G"
        \| "H" \| "I" \| "J" \| "K" \| "L" \| "M" \| "N"
        \| "O" \| "P" \| "Q" \| "R" \| "S" \| "T" \| "U"
        \| "V" \| "W" \| "X" \| "Y" \| "Z"
        \| "a" \| "b" \| "c" \| "d" \| "e" \| "f" \| "g"
        \| "h" \| "i" \| "j" \| "k" \| "l" \| "m" \| "n"
        \| "o" \| "p" \| "q" \| "r" \| "s" \| "t" \| "u"
        \| "v" \| "w" \| "x" \| "y" \| "z";
   
   digit = "0" \| "1" \| "2" \| "3" \| "4" \| "5" \| "6" \| "7" \| "8" \| "9";
   
   specialCharacter = percent \| ampersand \| leftParen \| rightParen
                   \| asterisk \| plusSign \| comma \| minusSign
                   \| period \| solidus \| colon \| semicolon
                   \| lt \| gt \| eq \| questionMark \| underscore
                   \| verticalBar \| doubleQuote \| dotdot;
   
   octothorp = "#";
   
   dollar = "$";
   
   underscore = "_";
   
   doubleQuote = "\"";
   
   percent = "%";
   
   ampersand = "&";
   
   quote = "'";
   
   leftParen = "(";
   
   rightParen = ")";
   
   asterisk = "*";
   
   plusSign = "+";
   
   comma = ",";
   
   minusSign = "-";
   
   period = ".";
   
   dotdot = "..";
   
   solidus = "/";
   
   colon = ":";
   
   semicolon = ";";
   
   lt = "<";
   
   eq = "=";

   gt = ">";

   questionMark = "?";

   verticalBar = "\|";

   bit = "0" \| "1";

   hexit = digit \| "A" \| "B" \| "C" \| "D" \| "E" \| "F"
                 \| "a" \| "b" \| "c" \| "d" \| "e" \| "f";

   #==========================================================================#
   # Definition of NUMERIC literals
   #==========================================================================#
   numericLiteral = unsignedNumericLiteral \| signedNumericLiteral;
   
   unsignedNumericLiteral = exactNumericLiteral \| approximateNumericLiteral;
   
   signedNumericLiteral = \[sign\] exactNumericLiteral
                        \| approximateNumericLiteral;
   
   exactNumericLiteral = unsignedInteger \[ period \[ unsignedInteger \] \]
                       \| period unsignedInteger;
   
   approximateNumericLiteral = mantissa "E" exponent;
   
   mantissa = exactNumericLiteral;
   
   exponent = signedInteger;
   
   signedInteger = \[ sign \] unsignedInteger;
   
   unsignedInteger = {digit};
   
   sign = plusSign \| minusSign;
   
   #==========================================================================#
   # Boolean literal                 
   #==========================================================================#
   #
   booleanLiteral = "TRUE" \| "true" \| "FALSE" \| "false" \|
                    "T" \| "t" \| "F" \| "f" \| "1" \| "0";
   
   #==========================================================================#
   # Definition of GEOMETRIC literals
   #
   # NOTE: This is basically BNF that define WKT encoding; it would be nice
   #       to instead reference some normative BNF for WKT.
   #==========================================================================#
   geomLiteral = pointTaggedText
              \| linestringTaggedText
              \| polygonTaggedText
              \| multipointTaggedText
              \| multilinestringTaggedText
              \| multipolygonTaggedText
              \| geometryCollectionTaggedText
              \| envelopeTaggedText;
   
   pointTaggedText = "POINT" pointText;
   
   linestringTaggedText = "LINESTRING" lineStringText;
   
   polygonTaggedText = "POLYGON" polygonText;
   
   multipointTaggedText = "MULTIPOINT" multiPointText;
   
   multilinestringTaggedText = "MULTILINESTRING" multiLineStringText;
   
   multipolygonTaggedText = "MULTIPOLYGON" multiPolygonText;
   
   geometryCollectionTaggedText = "GEOMETRYCOLLECTION" geometryCollectionText;
   
   pointText = leftParen point rightParen;
   
   point = xCoord yCoord \[zCoord\];
   
   xCoord = signedNumericLiteral;
   
   yCoord = signedNumericLiteral;
   
   zCoord = signedNumericLiteral;
   
   lineStringText = leftParen point {comma point} rightParen;
   
   polygonText =  leftParen lineStringText {comma lineStringText} rightParen;
   
   multiPointText = leftParen pointText {comma pointText} rightParen;
   
   multiLineStringText = leftParen lineStringText {comma lineStringText} rightParen;
   
   multiPolygonText = leftParen polygonText {comma polygonText} rightParen;
   
   geometryCollectionText = leftParen geomLiteral {comma geomLiteral} rightParen;
   
   envelopeTaggedText = "ENVELOPE" envelopeText;
   
   envelopeText = leftParen westBoundLon comma
                  southBoundLat comma \[minElev comma\]
                  eastBoundLon comma
                  northBoundLat \[comma maxElev\] rightParen; 
   
   westBoundLon = signedNumericLiteral;
   
   eastBoundLon = signedNumericLiteral;
   
   northBoundLat = signedNumericLiteral;
   
   southBoundLat = signedNumericLiteral;
   
   minElev = signedNumericLiteral;
   
   maxElev = signedNumericLiteral;
   
   #==========================================================================#
   # Definition of TEMPORAL literals
   #
   # NOTE: Is the fact the time zones are supported too complicated for a
   #       simple CQL?  Perhaps the "core" of CQL should just support UTC.
   #==========================================================================#
   temporalLiteral = instant \| interval;
   
   instant = fullDate \| fullDate "T" utcTime;
   
   interval = solidus
           \| solidus dotdot
           \| dotdot solidus
           \| instant solidus
           \| solidus instant
           \| instant solidus dotdot
           \| dotdot solidus instant
           \| instant solidus instant;
   
   fullDate   = dateYear "-" dateMonth "-" dateDay;
   
   dateYear   = digit digit digit digit;
   
   dateMonth  = digit digit;
   
   dateDay    = digit digit;
   
   utcTime  = timeHour ":" timeMinute ":" timeSecond \[timeZoneOffset\];
   
   timeZoneOffset = "Z" \| sign timeHour;
   
   timeHour   = digit digit;
   
   timeMinute = digit digit;
   
   timeSecond = digit digit \[period digit {digit}\];
----
|===
