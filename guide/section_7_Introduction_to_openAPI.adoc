== Section 7: Introduction to OpenAPI

=== Section

The OpenAPI Specification is a community-driven open specification within the OpenAPI Initiative, a Linux Foundation Collaborative Project.

The OpenAPI Specification (OAS) defines a standard, programming language-agnostic interface description for REST APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interface descriptions have done for lower-level programming, the OpenAPI Specification removes guesswork in calling a service.

Use cases for machine-readable API definition documents include, but are not limited to: interactive documentation; code generation for documentation, clients, and servers; and automation of test cases. OpenAPI documents describe an API's services and are represented in either YAML or JSON formats. These documents may either be produced and served statically or be generated dynamically from an application.

The OpenAPI Specification does not require rewriting existing APIs. It does not require binding any software to a service — the service being described may not even be owned by the creator of its description. It does, however, require the capabilities of the service be described in the structure of the OpenAPI Specification. Not all services can be described by OpenAPI — this specification is not intended to cover every possible style of REST APIs. The OpenAPI Specification does not mandate a specific development process such as design-first or code-first. It does facilitate either technique by establishing clear interactions with a REST API.

This GitHub project is the starting point for OpenAPI. Here you will find the information you need about the OpenAPI Specification, simple examples of what it looks like, and some general information regarding the project.


The OpenAPI specification currently supports the following link:https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#security-scheme-object[security schemes]:

* HTTP authentication,
* an API key (either as a header or as a query parameter),
* OAuth2's common flows (implicit, password, application and access code) as defined in RFC6749, and
* OpenID Connect Discovery.

=== Building the URLs

An OpenAPI document can describe a large number of URLs.  Extracting all of the URLs is a non-trivial task.  The OpenAPI objects used to construct URLs are:   

* Server Objects (URL template for the root and variables to populate it)
* Paths Objects (URL template for the path and parameters)
* Operation Objects (including parameters)

They are organized as follows:

{Server Object}/{Path Object}/?{Parameters}

 IF Server Objects are supplied 
     THEN save them for latter
     ELSE create a Server Object for the host of the OpenAPI document
 DO FOR each Path
     IF Server Objects are included, THEN 
         Use them instead of those previously identified
     IF Parameter Objects are included, THEN
         save them for latter
     DO FOR Each Operation
         IF Server Objects are included, THEN 
             Use them instead of those previously identified
         IF Parameter Objects are included THEN
             IF this parameter was previously defined 
                 THEN replace the previous definition
                 ELSE add this parameter to the set.
         DO FOR Each Server Object
             Extract all URL roots 
             DO FOR each URL root
                 Concatinate the URL root and Path to create a working URL
                 Concatinate the working URL with the Parameters
                 Save the completed URL for future use
             CONTINUE
         DONE
     DONE
 DONE


==== Server Objects

Server Objects may be found at the OpenAPI document, Path Object, and Operation Object level.  Given this potentially large number of servers, how do you create the valid paths?

We can assume that the authors of a OAS document are not doing it for their personal enjoyment.  Therefore, if a Server Object is included, there must be a reason for its' presence.  So the Server Objects with the most restrictive scope are the ones we should use.  Clients should look for Server Objects in the following order:  

. The Operation Object, 
. Then Path Item, 
. The root. 
The first scope where a Server Object is found dictates the behavior completely.

CAUTION: link:https://github.com/opengeospatial/WFS_FES/issues/41[ISSUE 41] +
How does a client determine which security protocols/standards/etc. a server supports

=== Extensions to OAS
The OpenAPI Technnical Steering Committee (TSC) has added support for _draft_ features to the OAS development process.  These features will be introduced as OAI approved extensions. By introducing new features this way, new features can be designed, documented and then implemented by tools that are interested in the feature, without putting the burden of implementation on all tooling. If the feature is successfully implemented and there is demonstrable value added by the feature, it will become a candidate for inclusion in a future release of the specification, at which point all tools will be expected to support the feature.

Draft feature extensions are identified by the x-oas-draft- prefix and can only be used where existing extensions are permitted. This ensures no existing tooling will affected by the introduction of the draft feature. If the feature is deemed appropriate for inclusion in the OAS, the x-oas-draft- prefix will be removed. Tooling that supports draft features should plan for the future removal of the prefix. When tooling adds support for a later version of OAS that includes the final implementation of the feature, it MUST not support the use of the draft prefix for that feature. Draft features will only be promoted into minor or major releases of the specification and therefore will be transparent to OpenAPI description writers and tooling providers who choose not to use the feature while in its draft state.

Draft features will be documented as GitHub issues and labeled with the draft-feature label and will be initially labelled as draft:proposal. When the proposal is considered sufficiently stable for pilot implementation, it will be labeled draft:pilot. If during the development of a draft feature, it is determined that the feature needs to change in a way that may break existing draft implementations, the extension name itself may be versioned with a version suffix. e.g. -v2 When a draft feature becomes part of a future update to the specification any version suffix will be removed. Draft features that are deemed not appropriate for inclusion MUST be marked with the draft:abandoned label. Draft-features that are considered suitably specified and have had successful pilot implementations will be marked with the draft:graduated label.

Not all future new features will be introduced in this way. Some new features impact the specification in ways that cannot be encapsulated in an extension. However, where a new feature can be introduced in this way, it should be.
