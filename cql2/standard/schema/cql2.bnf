#
# MODULE:  cql2.bnf
# PURPOSE: A BNF grammar for the Common Query Language (CQL2).
# HISTORY:
# DATE         EMAIL                                  DESCRIPTION
# 13-SEP-2019  pvretano[at]cubewerx.com               Initial creation
# 28-OCT-2019  pvretano[at]cubewerx.com               Initial check-in into github
# 22-DEC-2020  pvretano[at]cubewerx.com               1.0.0-draft.1 (version for public review)
#              portele[at]interactive-instruments.de  
# xx-MAY-2022  pvretano[at]cubewerx.com               1.0.0-rc.1 (release candidate)
#              portele[at]interactive-instruments.de  

#=============================================================================#
# A CQL2 filter is a logically connected expression of one or more predicates.
# Predicates include scalar or comparison predicates, spatial predicates or
# temporal predicates.
#
# NOTE: Validated using: https://www.icosaedro.it/bnf_chk/bnf_chk-on-line.html
#=============================================================================#
booleanExpression = andExpression 
                  | orExpression
                  | notExpression
                  | comparisonPredicate
                  | spatialPredicate
                  | temporalPredicate
                  | arrayPredicate
                  | subExpression
                  | booleanLiteral;

andExpression = booleanExpression "AND" booleanExpression;

orExpression = booleanExpression "OR" booleanExpression;

notExpression = "NOT" booleanExpression;

subExpression = leftParen booleanExpression rightParen;

#=============================================================================#
# A comparison predicate evaluates if two scalar expression statisfy the
# specified comparison operator.  The comparion operators includes an operator
# to evaluate pattern matching expressions (LIKE), a range evaluation operator
# and an operator to test if a scalar expression is NULL or not.
#=============================================================================#
comparisonPredicate = binaryComparisonPredicate
                    | isLikePredicate
                    | isBetweenPredicate
                    | isInListPredicate
                    | isNullPredicate;

# Binary comparison predicate
#
binaryComparisonPredicate = scalarExpression
                            comparisonOperator
                            scalarExpression;

scalarExpression = characterExpression
                 | temporalInstantExpression
                 | numericExpression
                 | booleanExpression;

temporalInstantExpression = instantLiteral
                          | propertyName
                          | function;

comparisonOperator = eq | neq | lt | gt | lteq | gteq;

neq = lt gt;

gteq = gt eq;

lteq = lt eq;

# LIKE predicate
#
isLikePredicate =  characterExpression ["NOT"] "LIKE" patternExpression;

patternExpression = "CASEI" leftParen patternExpression rightParen
                  | "ACCENTI" leftParen patternExpression rightParen
                  | characterLiteral;

# BETWEEN predicate
#
isBetweenPredicate = numericExpression ["NOT"] "BETWEEN"
                     numericExpression "AND" numericExpression;

numericExpression = arithmeticExpression
                  | numericLiteral
                  | propertyName
                  | function;

# IN LIST predicate
#
isInListPredicate = scalarExpression ["NOT"] "IN" leftParen inList rightParen;

inList = scalarExpression [ {comma scalarExpression} ];

# IS NULL predicate
#
isNullPredicate = isNullOperand "IS" ["NOT"] "NULL";

isNullOperand = characterExpression
              | numericExpression
              | temporalExpression
              | booleanExpression
              | geomExpression;

#=============================================================================#
# A spatial predicate evaluates if two spatial expressions satisfy the
# specified spatial operator.
#=============================================================================#
spatialPredicate =  spatialOperator
                    leftParen geomExpression comma geomExpression rightParen;

# NOTE: The buffer operators (DWITHIN and BEYOND) are not included because
#       these are outside the scope of a "simple" core for CQL2.  These
#       can be added as extensions.
#
spatialOperator = "S_INTERSECTS"
                | "S_EQUALS"
                | "S_DISJOINT"
                | "S_TOUCHES"
                | "S_WITHIN"
                | "S_OVERLAPS"
                | "S_CROSSES"
                | "S_CONTAINS";

# A geometric expression is a property name of a geometry-valued property,
# a geometric literal (expressed as WKT) or a function that returns a
# geometric value.
#
geomExpression = spatialLiteral
               | propertyName
               | function;

#=============================================================================#
# A temporal predicate evaluates if two temporal expressions satisfy the
# specified temporal operator.
#=============================================================================#
temporalPredicate = temporalOperator 
                    leftParen temporalExpression comma temporalExpression rightParen;

temporalExpression = temporalLiteral
                   | propertyName
                   | function;

temporalOperator = "T_AFTER"
                 | "T_BEFORE"
                 | "T_CONTAINS"
                 | "T_DISJOINT"
                 | "T_DURING"
                 | "T_EQUALS"
                 | "T_FINISHEDBY"
                 | "T_FINISHES"
                 | "T_INTERSECTS"
                 | "T_MEETS"
                 | "T_METBY"
                 | "T_OVERLAPPEDBY"
                 | "T_OVERLAPS"
                 | "T_STARTEDBY"
                 | "T_STARTS";

#=============================================================================#
# An array predicate evaluates if two array expressions statisfy the
# specified array operator.  Arrays can be equal, one is a superset of
# the other, one is a subset of the other and the two arrays have
# overlapping elements.
#=============================================================================#
arrayPredicate = arrayOperator
                 leftParen arrayExpression comma arrayExpression rightParen;

# An array expression is a bracket-delimited, comma-separated list of array
# elements.  An array element is either a character literal, a numeric literal,
# a geometric literal, a temporal literal, a property name, a function, an
# arithmetic expression or an array.
#
arrayExpression = arrayLiteral
                | propertyName
                | function;

arrayLiteral = leftBracket rightBracket
             | leftBracket arrayElement [ { comma arrayElement } ] rightBracket;

arrayElement = characterExpression
             | temporalExpression
             | numericExpression
             | booleanExpression
             | geomExpression
             | arrayExpression;

arrayOperator = "A_EQUALS"
              | "A_CONTAINS"
              | "A_CONTAINEDBY"
              | "A_OVERLAPS";

#=============================================================================#
# An arithemtic expression is an expression composed of an arithmetic
# operand (a property name, a number or a function that returns a number),
# an arithmetic operators (+,-,*,/) and another arithmetic operand.
#=============================================================================#
arithmeticExpression = arithmeticExpression plusSign arithmeticTerm
                     | arithmeticExpression minusSign arithmeticTerm
                     | arithmeticTerm;
arithmeticTerm = arithmeticTerm asterisk powerTerm
               | arithmeticTerm solidus powerTerm
               | powerTerm;
powerTerm = arithmeticFactor caret powerTerm
          | arithmeticFactor;
arithmeticFactor = leftParen arithmeticExpression rightParen
                 | arithmeticOperand;
arithmeticOperand = numericLiteral
                  | propertyName
                  | function;

#=============================================================================#
# Definition of a PROPERTYNAME
# Production copied from: https://www.w3.org/TR/REC-xml/#sec-common-syn,
#                         "Names and Tokens".
#=============================================================================#
propertyName = identifier | doubleQuote identifier doubleQuote;

identifier = identifierStart [ { identifierPart } ];

identifierPart = identifierStart | dash | period | digit |
                 "\x0300".."\x036F" | "\x203F".."\x0240";

identifierStart = colon | underscore |
                  "\x0041".."\x0051" |
                  "\x0061".."\x0071" |
                  "\x00C0".."\x00D6" |
                  "\x00D8".."\x00F6" |
                  "\x00F8".."\x02FF" |
                  "\x0370".."\x037D" |
                  "\x037F".."\x1FFF" |
                  "\x200C".."\x200D" |
                  "\x2070".."\x218F" |
                  "\x2C00".."\x2FEF" |
                  "\x3001".."\xD7FF" |
                  "\xF900".."\xFDCF" |
                  "\xFDF0".."\xFFFD" |
                  "\x10000".."\xEFFFF"

#=============================================================================#
# Definition of a FUNCTION
# The functions offered by an implementation are provided at `/functions`
#=============================================================================#
function = identifier leftParen {argumentList} rightParen;

argumentList = argument [ { comma argument } ];

argument = characterExpression
         | numericExpression
         | temporalExpression
         | booleanExpression
         | geomExpression
         | arrayExpression;

#=============================================================================#
# Character expression
#=============================================================================#
characterExpression = "CASEI" leftParen characterExpression rightParen
                    | "ACCENTI" leftParen characterExpression rightParen
                    | characterLiteral
                    | propertyName
                    | function;

#=============================================================================#
# Definition of CHARACTER literals
#=============================================================================#
characterLiteral = quote [ {character} ] quote;

character = alpha | digit | escapedquote;

# character & digit productions copied from:
# https://www.w3.org/TR/REC-xml/#charsets
#
alpha = "\x0009" | "\x000A" | "\x000D" | "\x0020".."\x0029" |
        "\x0040".."\xD7FF" | "\xE000".."\xFFFD" | "\x10000".."\x10FFFF"

digit = "\x0030".."\x0039";

underscore = "_";    # "\x005F"

doubleQuote = "\"";  # "\x0022"

quote = "'";         # "\x0027"

escapedquote = "''";

leftBracket = "[";   # "\x005B"

rightBracket = "]";  # "\x005D"

leftParen = "(";     # "\x0028"

rightParen = ")";    # "\x0029"

asterisk = "*";      # "\x002A"

plusSign = "+";      # "\x002B"

comma = ",";         # "\x002C"

minusSign = "-";     # "\x002D"

period = ".";        # "\x002E"

dotdot = "..";

solidus = "/";       # "\x002F"

colon = ":";         # "\x003A"

lt = "<";            # "\x003C"

eq = "=";            # "\x003D"

gt = ">";            # "\x003F"

#=============================================================================#
# Definition of NUMERIC literals
#=============================================================================#
numericLiteral = unsignedNumericLiteral | signedNumericLiteral;

unsignedNumericLiteral = exactNumericLiteral | approximateNumericLiteral;

signedNumericLiteral = [sign] exactNumericLiteral | approximateNumericLiteral;

exactNumericLiteral = unsignedInteger [ period [ unsignedInteger ] ]
                      | period unsignedInteger;

approximateNumericLiteral = mantissa "E" exponent;

mantissa = exactNumericLiteral;

exponent = signedInteger;

signedInteger = [ sign ] unsignedInteger;

unsignedInteger = {digit};

sign = plusSign | minusSign;

#=============================================================================#
# Boolean literal
#=============================================================================#
#
booleanLiteral = "TRUE" | "FALSE";

#=============================================================================#
# Definition of GEOMETRIC literals
#
# NOTE: This is basically BNF that define WKT encoding. It would be nice
#       to instead reference some normative BNF for WKT.
#=============================================================================#
spatialLiteral = pointTaggedText
               | linestringTaggedText
               | polygonTaggedText
               | multipointTaggedText
               | multilinestringTaggedText
               | multipolygonTaggedText
               | geometryCollectionTaggedText
               | envelopeTaggedText;

pointTaggedText = "POINT" pointText;

linestringTaggedText = "LINESTRING" lineStringText;

polygonTaggedText = "POLYGON" polygonText;

multipointTaggedText = "MULTIPOINT" multiPointText;

multilinestringTaggedText = "MULTILINESTRING" multiLineStringText;

multipolygonTaggedText = "MULTIPOLYGON" multiPolygonText;

geometryCollectionTaggedText = "GEOMETRYCOLLECTION" geometryCollectionText;

pointText = leftParen point rightParen;

point = xCoord yCoord [zCoord];

xCoord = signedNumericLiteral;

yCoord = signedNumericLiteral;

zCoord = signedNumericLiteral;

lineStringText = leftParen point {comma point} rightParen;

polygonText =  leftParen lineStringText {comma lineStringText} rightParen;

multiPointText = leftParen pointText {comma pointText} rightParen;

multiLineStringText = leftParen lineStringText {comma lineStringText} rightParen;

multiPolygonText = leftParen polygonText {comma polygonText} rightParen;

geometryCollectionText = leftParen
                         spatialLiteral {comma spatialLiteral} rightParen;

envelopeTaggedText = "ENVELOPE" envelopeText;

envelopeText = leftParen westBoundLon comma southBoundLat comma [minElev comma] eastBoundLon comma northBoundLat [comma maxElev] rightParen;

westBoundLon = signedNumericLiteral;

eastBoundLon = signedNumericLiteral;

northBoundLat = signedNumericLiteral;

southBoundLat = signedNumericLiteral;

minElev = signedNumericLiteral;

maxElev = signedNumericLiteral;

temporalLiteral = instantLiteral | intervalLiteral;

instantLiteral = dateInstant | timestampInstant;

dateInstant = "DATE" 
              leftParen dateInstantString rightParen;

dateInstantString = quote fullDate quote;

timestampInstant = "TIMESTAMP" 
                   leftParen timestampInstantString rightParen;

timestampInstantString = quote fullDate "T" utcTime quote;

intervalLiteral = "INTERVAL" 
                  leftParen instantParameter comma instantParameter rightParen;

instantParameter = dateInstantString
                 | timestampInstantString
                 | quote dotdot quote
                 | propertyName
                 | function;

fullDate   = dateYear "-" dateMonth "-" dateDay;

dateYear   = digit digit digit digit;

dateMonth  = digit digit;

dateDay    = digit digit;

utcTime  = timeHour ":" timeMinute ":" timeSecond "Z";

timeHour   = digit digit;

timeMinute = digit digit;

timeSecond = digit digit [period digit {digit}];
