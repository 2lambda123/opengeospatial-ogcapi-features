#
# MODULE:  cql2.bnf
# PURPOSE: A BNF grammar for the Common Query Language (CQL2).
# HISTORY:
# DATE         EMAIL                                  DESCRIPTION
# 13-SEP-2019  pvretano[at]cubewerx.com               Initial creation
# 28-OCT-2019  pvretano[at]cubewerx.com               Initial check-in into github
# 22-DEC-2020  pvretano[at]cubewerx.com               1.0.0-draft.1 (version for public review)
#              portele[at]interactive-instruments.de  
# xx-MAY-2022  pvretano[at]cubewerx.com               1.0.0-rc.1 (release candidate)
#              portele[at]interactive-instruments.de  

#=============================================================================#
# A CQL2 filter is a logically connected expression of one or more predicates.
# Predicates include scalar or comparison predicates, spatial predicates or
# temporal predicates.
#
# NOTE: Validated using: https://www.icosaedro.it/bnf_chk/bnf_chk-on-line.html
#=============================================================================#
booleanExpression = booleanTerm [ {"OR" booleanTerm} ];

booleanTerm = booleanFactor [ {"AND" booleanFactor} ];

booleanFactor = ["NOT"] booleanPrimary;

booleanPrimary = predicate
               | booleanLiteral
               | leftParen booleanExpression rightParen;

predicate = comparisonPredicate
          | spatialPredicate
          | temporalPredicate
          | arrayPredicate;

#=============================================================================#
# A comparison predicate evaluates if two scalar expression statisfy the
# specified comparison operator.  The comparion operators includes an operator
# to evaluate pattern matching expressions (LIKE), a range evaluation operator
# and an operator to test if a scalar expression is NULL or not.
#=============================================================================#
comparisonPredicate = binaryComparisonPredicate
                    | isLikePredicate
                    | isBetweenPredicate
                    | isInListPredicate
                    | isNullPredicate;

# Binary comparison predicate
#
binaryComparisonPredicate = scalarExpression
                            comparisonOperator
                            scalarExpression;

scalarExpression = characterClause
                 | numericLiteral
                 | instantInstance
                 | arithmeticExpression
                 | booleanExpression
                 | propertyName
                 | function;

comparisonOperator = eq | neq | lt | gt | lteq | gteq;

neq = lt gt;

gteq = gt eq;

lteq = lt eq;

# LIKE predicate
#
isLikePredicate =  characterExpression ["NOT"] "LIKE" patternExpression;

patternExpression = "CASEI" leftParen patternExpression rightParen
                  | "ACCENTI" leftParen patternExpression rightParen
                  | characterLiteral;

# BETWEEN predicate
#
isBetweenPredicate = numericExpression ["NOT"] "BETWEEN"
                     numericExpression "AND" numericExpression;

numericExpression = arithmeticExpression
                  | numericLiteral
                  | propertyName
                  | function;

# IN LIST predicate
#
isInListPredicate = scalarExpression ["NOT"] "IN" leftParen inList rightParen;

inList = scalarExpression [ {comma scalarExpression} ];

# IS NULL predicate
#
isNullPredicate = isNullOperand "IS" ["NOT"] "NULL";

isNullOperand = characterClause
              | numericLiteral
              | temporalInstance
              | spatialInstance
              | arithmeticExpression
              | booleanExpression
              | propertyName
              | function;

#=============================================================================#
# A spatial predicate evaluates if two spatial expressions satisfy the
# condition implied by a standardized spatial comparison function.  If the
# conditions of the spatial comparison function are met, the function returns
# a Boolean value of true.  Otherwise the function returns false.
#=============================================================================#
spatialPredicate =  spatialFunction
                    leftParen geomExpression comma geomExpression rightParen;

# NOTE: The buffer functions (DWITHIN and BEYOND) are not included because
#       these are outside the scope of a "simple" core for CQL2.  These
#       can be added as extensions.
#
spatialFunction = "S_INTERSECTS"
                | "S_EQUALS"
                | "S_DISJOINT"
                | "S_TOUCHES"
                | "S_WITHIN"
                | "S_OVERLAPS"
                | "S_CROSSES"
                | "S_CONTAINS";

# A geometric expression is a property name of a geometry-valued property,
# a geometric literal (expressed as WKT) or a function that returns a
# geometric value.
#
geomExpression = spatialInstance
               | propertyName
               | function;

#=============================================================================#
# A temporal predicate evaluates if two temporal expressions satisfy the
# condition implied by a standardized temporal comparison function.  If the
# conditions of the temporal comparison function are met, the function returns
# a Boolean value of true.  Otherwise the function returns false.
#=============================================================================#
temporalPredicate = temporalFunction 
                    leftParen temporalExpression comma temporalExpression rightParen;

temporalExpression = temporalInstance
                   | propertyName
                   | function;

temporalFunction = "T_AFTER"
                 | "T_BEFORE"
                 | "T_CONTAINS"
                 | "T_DISJOINT"
                 | "T_DURING"
                 | "T_EQUALS"
                 | "T_FINISHEDBY"
                 | "T_FINISHES"
                 | "T_INTERSECTS"
                 | "T_MEETS"
                 | "T_METBY"
                 | "T_OVERLAPPEDBY"
                 | "T_OVERLAPS"
                 | "T_STARTEDBY"
                 | "T_STARTS";

#=============================================================================#
# An array predicate evaluates if two array expressions satisfy the
# condition implied by a standardized array comparison function.  If the
# conditions of the array comparison function are met, the function returns
# a Boolean value of true.  Otherwise the function returns false.
#=============================================================================#
arrayPredicate = arrayFunction
                 leftParen arrayExpression comma arrayExpression rightParen;

arrayExpression = arrayInstance
                | propertyName
                | function;

# An array is a bracket-delimited, comma-separated list of array elements.
arrayInstance = leftParen rightParen
              | leftParen arrayElement [ { comma arrayElement } ] rightParen;

# An array element is either a character literal, a numeric literal,
# a geometric literal, a temporal instance, a property name, a function,
# an arithmetic expression or an array.
arrayElement = characterClause
             | numericLiteral
             | temporalInstance
             | spatialInstance
             | arrayInstance
             | arithmeticExpression
             | booleanExpression
             | propertyName
             | function;

arrayFunction = "A_EQUALS"
              | "A_CONTAINS"
              | "A_CONTAINEDBY"
              | "A_OVERLAPS";

#=============================================================================#
# An arithmetic expression is an expression composed of an arithmetic
# operand (a property name, a number or a function that returns a number),
# an arithmetic operators (+,-,*,/,%,div,^) and another arithmetic operand.
#=============================================================================#

arithmeticExpression = arithmeticTerm [ {arithmeticOperatorPlusMinus arithmeticTerm} ];

arithmeticOperatorPlusMinus = plusSign | minusSign;

arithmeticTerm = powerTerm [ {arithmeticOperatorMultDiv powerTerm} ];

arithmeticOperatorMultDiv = asterisk | solidus | percent | "div";

powerTerm = arithmeticFactor [ caret arithmeticFactor ];

arithmeticFactor = leftParen arithmeticExpression rightParen
                 | [ minusSign ] arithmeticOperand;

arithmeticOperand = numericLiteral
                  | propertyName
                  | function;

#=============================================================================#
# Definition of a PROPERTYNAME
# Production copied from: https://www.w3.org/TR/REC-xml/#sec-common-syn,
#                         "Names and Tokens".
#=============================================================================#
propertyName = identifier | doubleQuote identifier doubleQuote;

identifier = identifierStart [ { identifierPart } ];

identifierPart = identifierStart |
                 period |              # "\x002E"
                 digit  |              # 0-9
                 "\x0300".."\x036F" |  # combining and diacritical marks
                 "\x203F".."\x2040";   # ‿ and ⁀

identifierStart = colon |              # \x003A
                  underscore |         # \x005F
                  "\x0041".."\x005A" | # A-Z
                  "\x0061".."\x007A" | # a-z
                  "\x00C0".."\x00D6" | # À-Ö Latin-1 Supplement Letters
                  "\x00D8".."\x00F6" | # Ø-ö Latin-1 Supplement Letters
                  "\x00F8".."\x02FF" | # ø-ÿ Latin-1 Supplement Letters
                  "\x0370".."\x037D" | # Ͱ-ͽ Greek and Coptic (without ";")
                  "\x037F".."\x1FFE" | # See note 1.
                  "\x200C".."\x200D" | # zero width non-joiner and joiner
                  "\x2070".."\x218F" | # See note 2.
                  "\x2C00".."\x2FEF" | # See note 3.
                  "\x3001".."\xD7FF" | # See note 4.
                  "\xF900".."\xFDCF" | # See note 5.
                  "\xFDF0".."\xFFFD" | # See note 6.
                  "\x10000".."\xEFFFF" # See note 7.

# See: https://unicode-table.com/en/blocks/

# Note 1: Greek, Coptic, Cyrillic, Cyrillic Supplement, Armenian, Hebrew,
#         Arabic, Syriac, Arabic Supplement, Thaana, NKo, Samaritan, Mandaic,
#         Syriac Supplement, Arabic Extended-A, Devanagari, Bengali, Gurmukhi,
#         Gujarati, Oriya, Tamil, Telugu, Kannada, Malayalam, Sinhala, Thai,
#         Lao, Tibetan, Myanmar, Georgian, Hangul Jamo, Ethiopic, Ethiopic
#         Supplement, Cherokee, Unified Canadian Aboriginal Syllabics, Ogham,
#         Runic, Tagalog, Hanunoo, Buhid, Tagbanwa, Khmer, Mongolian, Unified
#         Canadian Aboriginal Syllabics Extended, Limbu, Tai Le, New Tai Lue,
#         Khmer Symbols, Buginese, Tai Tham, Combining Diacritical Marks
#         Extended, Balinese, Sundanese, Batak, Lepcha, Ol Chiki, Cyrillic
#         Extended C, Georgian Extended, Sundanese Supplement, Vedic
#         Extensions, Phonetic Extensions, Phonetic Extensions Supplement,
#         Combining Diacritical Marks Supplement, Latin Extended Additional,
#         Greek Extended
#
# Note 2: Superscripts and Subscripts, Currency Symbols, Combining Diacritical
#         Marks for Symbols, Letterlike Symbols, Number Forms (e.g. Roman
#         numbers)
#
# Note 3: Glagolitic, Latin Extended-C, Coptic, Georgian Supplement, Tifinagh,
#         Ethiopic Extended, Cyrillic Extended-A, Supplemental Punctuation,
#         CJK Radicals Supplement, Kangxi Radicals
#
# Note 4: CJK Symbols and Punctuation Hiragana, Katakana, Bopomofo, Hangul
#         Compatibility Jamo, Kanbun, Bopomofo Extended, CJK Strokes, Katakana
#         Phonetic Extensions, Enclosed CJK Letters and Months, CJK
#         Compatibility, CJK Unified Ideographs Extension A, Yijing Hexagram
#         Symbols, CJK Unified Ideographs, Yi Syllables, Yi Radicals, Lisu,
#         Vai, Cyrillic Extended-B, Bamum, Modifier Tone Letters, Latin
#         Extended-D, Syloti Nagri, Common Indic Number Forms, Phags-pa,
#         Saurashtra, Devanagari Extended, Kayah Li, Rejang, Hangul Jamo
#         Extended-A, Javanese, Myanmar Extended-B, Cham, Myanmar Extended-A,
#         Tai Viet, Meetei Mayek Extensions, Ethiopic Extended-A, Latin
#         Extended-E, Cherokee Supplement, Meetei Mayek, Hangul Syllables,
#         Hangul Jamo Extended-B
#
# Note 5: CJK Compatibility Ideographs, Alphabetic Presentation Forms, 
#         Arabic Presentation Forms-A
#
# Note 6: Arabic Presentation Forms-A, Variation Selectors, Vertical Forms,
#         Combining Half Marks, CJK Compatibility Forms, Small Form Variants,
#         Arabic Presentation Forms-B, Halfwidth and Fullwidth Forms, Specials
#
# Note 7: Linear B Syllabary, Linear B Ideograms, Aegean Numbers, Ancient
#         Greek Numbers, Ancient Symbols, Phaistos Disc, Lycian, Carian,
#         Coptic Epact Numbers, Old Italic, Gothic, Old Permic, Ugaritic, Old
#         Persian, Deseret, Shavian, Osmanya, Osage, Elbasan, Caucasian
#         Albanian, Linear A, Cypriot Syllabary, Imperial Aramaic, Palmyrene,
#         Nabataean, Hatran, Phoenician, Lydian, Meroitic Hieroglyphs,
#         Meroitic Cursive, Kharoshthi, Old South Arabian, Old North Arabian,
#         Manichaean, Avestan, Inscriptional Parthian, Inscriptional Pahlavi,
#         Psalter Pahlavi, Old Turkic, Old Hungarian, Hanifi Rohingya, Rumi
#         Numeral Symbols, Yezidi, Old Sogdian, Sogdian, Chorasmian, Elymaic,
#         Brahmi, Kaithi, Sora Sompeng, Chakma, Mahajani, Sharada, Sinhala
#         Archaic Numbers, Khojki, Multani, Khudawadi, Grantha, Newa, Tirhuta,
#         Siddham, Modi, Mongolian Supplement, Takri, Ahom, Dogra, Warang Citi,
#         Dives Akuru, Nandinagari, Zanabazar Square, Soyombo, Pau Cin Hau,
#         Bhaiksuki, Marchen, Masaram Gondi, Gunjala Gondi, Makasar, Lisu
#         Supplement, Tamil Supplement, Cuneiform, Cuneiform Numbers and
#         Punctuation, Early Dynastic Cuneiform, Egyptian Hieroglyphs,
#         Egyptian Hieroglyph Format Controls, Anatolian Hieroglyphs,Bamum
#         Supplement, Mro, Bassa Vah, Pahawh Hmong, Medefaidrin, Miao,
#         Ideographic Symbols and Punctuation, Tangut, Tangut Components,
#         Khitan Small Script, Tangut Supplement, Kana Supplement, Kana
#         Extended-A, Small Kana Extension, Nushu, Duployan, Shorthand Format
#         Controls, Byzantine Musical Symbols, Musical Symbols, Ancient Greek
#         Musical Notation, Mayan Numerals, Tai Xuan Jing Symbols, Counting
#         Rod Numerals, Mathematical Alphanumeric Symbols, Sutton SignWriting,
#         Glagolitic Supplement, Nyiakeng Puachue Hmong, Wancho, Mende Kikakui,
#         Adlam, Indic Siyaq Numbers, Ottoman Siyaq Numbers, Arabic
#         Mathematical Alphabetic Symbols, Mahjong Tiles, Domino Tiles,
#         Playing Cards, Enclosed Alphanumeric Supplement, Enclosed Ideographic
#         Supplement, Miscellaneous Symbols and Pictographs, Emoticons (Emoji),
#         Ornamental Dingbats, Transport and Map Symbols, Alchemical Symbols,
#         Geometric Shapes Extended, Supplemental Arrows-C, Supplemental
#         Symbols and Pictographs, Chess Symbols, Symbols and Pictographs
#         Extended-A, Symbols for Legacy Computing, CJK Unified Ideographs
#         Extension B, CJK Unified Ideographs Extension C, CJK Unified
#         Ideographs Extension D, CJK Unified Ideographs Extension E, CJK
#         Unified Ideographs Extension F, CJK Compatibility Ideographs
#         Supplement, CJK Unified Ideographs Extension G, Tags, Variation
#         Selectors Supplement

#=============================================================================#
# Definition of a FUNCTION
#=============================================================================#
function = identifier leftParen {argumentList} rightParen;

argumentList = argument [ { comma argument } ];

argument = characterClause
         | numericLiteral
         | temporalInstance
         | spatialInstance
         | arrayInstance
         | arithmeticExpression
         | booleanExpression
         | propertyName
         | function;

#=============================================================================#
# Character expression
#=============================================================================#
characterExpression = characterClause
                    | propertyName
                    | function;

characterClause = "CASEI" leftParen characterExpression rightParen
                | "ACCENTI" leftParen characterExpression rightParen
                | characterLiteral;

#=============================================================================#
# Definition of CHARACTER literals
#=============================================================================#
characterLiteral = quote [ {character} ] quote;

character = alpha | digit | escapedquote;

# character & digit productions copied from:
# https://www.w3.org/TR/REC-xml/#charsets
#
alpha = "\x0009" | "\x000A" | "\x000D" | "\x0020".."\x0029" |
        "\x0040".."\xD7FF" | "\xE000".."\xFFFD" | "\x10000".."\x10FFFF"

digit = "\x0030".."\x0039";

underscore = "_";    # "\x005F"

doubleQuote = "\"";  # "\x0022"

quote = "'";         # "\x0027"

escapedquote = "''";

leftBracket = "[";   # "\x005B"

rightBracket = "]";  # "\x005D"

leftParen = "(";     # "\x0028"

rightParen = ")";    # "\x0029"

asterisk = "*";      # "\x002A"

plusSign = "+";      # "\x002B"

comma = ",";         # "\x002C"

minusSign = "-";     # "\x002D"

period = ".";        # "\x002E"

dotdot = "..";

solidus = "/";       # "\x002F"

colon = ":";         # "\x003A"

lt = "<";            # "\x003C"

eq = "=";            # "\x003D"

gt = ">";            # "\x003F"

caret = "^";

percent = "%";

#=============================================================================#
# Definition of NUMERIC literals
#=============================================================================#
numericLiteral = unsignedNumericLiteral | signedNumericLiteral;

unsignedNumericLiteral = exactNumericLiteral | approximateNumericLiteral;

signedNumericLiteral = [sign] exactNumericLiteral | approximateNumericLiteral;

exactNumericLiteral = unsignedInteger [ period [ unsignedInteger ] ]
                      | period unsignedInteger;

approximateNumericLiteral = mantissa "E" exponent;

mantissa = exactNumericLiteral;

exponent = signedInteger;

signedInteger = [ sign ] unsignedInteger;

unsignedInteger = {digit};

sign = plusSign | minusSign;

#=============================================================================#
# Boolean literal
#=============================================================================#
#
booleanLiteral = "TRUE" | "FALSE";

#=============================================================================#
# Definition of GEOMETRIC literals
#
# NOTE: This is basically BNF that define WKT encoding. It would be nice
#       to instead reference some normative BNF for WKT.
#=============================================================================#
spatialInstance = pointTaggedText
                | linestringTaggedText
                | polygonTaggedText
                | multipointTaggedText
                | multilinestringTaggedText
                | multipolygonTaggedText
                | geometryCollectionTaggedText
                | bboxTaggedText;

pointTaggedText = "POINT" pointText;

linestringTaggedText = "LINESTRING" lineStringText;

polygonTaggedText = "POLYGON" polygonText;

multipointTaggedText = "MULTIPOINT" multiPointText;

multilinestringTaggedText = "MULTILINESTRING" multiLineStringText;

multipolygonTaggedText = "MULTIPOLYGON" multiPolygonText;

geometryCollectionTaggedText = "GEOMETRYCOLLECTION" geometryCollectionText;

pointText = leftParen point rightParen;

point = xCoord yCoord [zCoord];

xCoord = signedNumericLiteral;

yCoord = signedNumericLiteral;

zCoord = signedNumericLiteral;

lineStringText = leftParen point {comma point} rightParen;

polygonText =  leftParen lineStringText {comma lineStringText} rightParen;

multiPointText = leftParen pointText {comma pointText} rightParen;

multiLineStringText = leftParen lineStringText {comma lineStringText} rightParen;

multiPolygonText = leftParen polygonText {comma polygonText} rightParen;

geometryCollectionText = leftParen
                         spatialInstance {comma spatialInstance} rightParen;

bboxTaggedText = "BBOX" bboxText;

bboxText = leftParen westBoundLon comma southBoundLat comma [minElev comma] eastBoundLon comma northBoundLat [comma maxElev] rightParen;

westBoundLon = signedNumericLiteral;

eastBoundLon = signedNumericLiteral;

northBoundLat = signedNumericLiteral;

southBoundLat = signedNumericLiteral;

minElev = signedNumericLiteral;

maxElev = signedNumericLiteral;

temporalInstance = instantInstance | intervalInstance;

instantInstance = dateInstant | timestampInstant;

dateInstant = "DATE" 
              leftParen dateInstantString rightParen;

dateInstantString = quote fullDate quote;

timestampInstant = "TIMESTAMP" 
                   leftParen timestampInstantString rightParen;

timestampInstantString = quote fullDate "T" utcTime quote;

intervalInstance = "INTERVAL" 
                   leftParen instantParameter comma instantParameter rightParen;

instantParameter = dateInstantString
                 | timestampInstantString
                 | quote dotdot quote
                 | propertyName
                 | function;

fullDate   = dateYear "-" dateMonth "-" dateDay;

dateYear   = digit digit digit digit;

dateMonth  = digit digit;

dateDay    = digit digit;

utcTime  = timeHour ":" timeMinute ":" timeSecond "Z";

timeHour   = digit digit;

timeMinute = digit digit;

timeSecond = digit digit [period digit {digit}];
